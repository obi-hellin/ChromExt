# 202208 빅데이터 파이널 프로젝트) KREAM 신발 리셀가 가이드


## II. 데이터
### 	가. 사용 데이터
		1) KREAM에 있는 신발 정보
		2) API를 따로 제공하고 있지 않기 때문에 직접 크롤링
### 	나. 크롤링
		1) 사용 라이브러리
			가) jupyer notebook
			나) Bs4
				- 상세 페이지의 신발 정보를 빠르게 크롤링하기 위해 사용
			다) Selenium
				- 상세페이지에 표시되는 거래내역은 한정적
				- 더 많은 거래내역을 보기 위해서는 브라우저 화면 조작이 필요했기에 사용
		2) 절차
			가) KREAM 로그인
			나) KREAM 상품 상세페이지에 접근) KREAM의 상품 상세페이지 URL은 'https://kream.co.kr/product/[상품번호]'
			다) 중복 크롤링을 방지하기 위해 같은 상품이 이미 저장되어있다면 pass
			마) bs4를 통해 파싱한 신발 정보 데이터를 딕셔너리 형태로 저장
				(1) bs4로 수집하는 정보 : 브랜드 / 콜라보브랜드 / 상품이름 / 출시일 / 색상 / 출시가 / 최근 5거래 평균가 / 상세페이지URL / 상품이미지
			바) Selenium을 통한 화면 조작으로 거래내역 더보기 -> 최근 50거래 내역을 파싱하여 저장 
			사) 상품번호를 1씩 증가시키며 반복
### 	다. 전처리
		1) 크롤링된 데이터 분석
			가) 최근 50거래 내역만 수집하였으나 수집된 거래내역 변수는 약 80개 -> 거래내역 수집에 오류가 있음
			나) 신발이 아닌 상품들이 수집됨
			다) 많은 결측치
			라) '000,000원' -> 문자열 형태로 저장된 숫자 변수
			마) 상품 이름에 붙어있는 (W) ? -> 여성용 신발
		2) 데이터 정제
			가) 거래내역이 비정상적으로 수집된 행을 삭제
			나) 상품 이름과 상품 이미지를 통해 수집 대상이 아닌 (신발이 아닌) 행을 삭제
			다) 이후 이미지 파일 ( 파일명 : [상품번호]_[상품이름].jpg ) 과 대조를 용이하게 하기위해 URL 변수에서 주소를 빼고 상품번호만 남김
			라) 출시가와 거래내역의 거래가를 분석에 용이하게 int 형태로 바꿈
			마) 출시일 변수를 int 형태로 변환 -> 2022.08.18 을 기준으로해 출시 경과일을 계산하여 변수값으로 사용
			바) 거래내역의 column명을 알아보기 쉽도록 (0~49) => (T1 ~ T50) 으로 변경
		3) 데이터 전처리
			가) 이미지 분석을 통해 새로운 변수 창출
				(1) sklearn KMEANS 
					(가) 정의 : 주어진 데이터를 K개의 군집으로 묶는 알고리즘, i번째 클러스터의 중심(평균) μi 를 기준으로 유클리드 거리를 계산해 가까이 있는 관측치들을 군집으로 묶는 clustering 기법. 비지도학습.
					(나) 선정 이유 : 기존에 알려진 정보인 신발의 브랜드나 모델명이 아닌 신발의 형태와 색상만을 기준으로 삼아 분류하고자 하였으므로 계산과정에서 임의로 군집이 설정되는 비지도학습 방법인 KMEANS 알고리즘을 사용하였다.
					(다) 군집 개수의 설정 : 수집된 이미지 약 18000개 중, 500개를 샘플링 ( 신뢰도 95%, 표준오차 4% 수준의 표집 ) 하여 선행 분석을 진행해본 결과 Elbow-Method를 통해 적게는 18개, 많게는 34개의 군집이 적당한 것으로 판단. 연산 시간이 생각보다 짧았으므로 시간적 여유가 충분하다 생각되어 군집의 개수는 34개로 결정하였다.
					(라) Clustering 결과
					      [KMEANS clustering 결과 사진]
				(2) KMEANS Clustering으로 도출된 결과를 데이터프레임으로 저장 후, 기존 데이터에 병합
				(3) 이미지 분석 결과에 이미 색상에 관한 정보가 고려되었다고 판단하여, 기존의 color 변수 제거
			나) 머신러닝을 위한 전처리 - Tensorflow keras ANN
				(1) 시계열 데이터를 고려하지 않으므로 거래내역 변수 삭제
				(2) 범주형 변수를 정수화
					(가) One-hot encoding
						① 개념 : n개의 범주를 가진 범주형 변수를 n개의 벡터로 풀어, 고유값에 해당하는 항목에만 1 값을, 나머지에는 0 값을 주는 더미변수화
						② 선정 이유 : Label encoding의 경우, 순서의 우열이 없는 범주조차 연속적인 정수로 인코딩하여, 선형 회귀 모델을 학습시킬 때, 정보의 왜곡이 발생함
					(나) 콜라보레이션 브랜드 -> 약 600개의 unique value, 모두를 고려하여 인코딩하면 데이터가 sparse 해질 것을 우려하여 콜라보 유무만을 표시하는 0,1 의 binary 변수로 변경
					(다) 브랜드 -> 약 64개의 unique value, 범주의 개수가 약간 많다고 생각되나, 모든 브랜드가 각자의 가치가 있어 정보를 손실시킬 수는 없다고 판단하여 One-hot encoding
					(라) Cluster -> 이미지 분류 결과로, 34개의 군집. 역시 브랜드가 각자의 가치가 있어 정보를 손실시킬 수는 없다고 판단하여 One-hot encoding
				(3) Outlier 탐색
					(가) matplotlib.pyplot 라이브러리를 통한 boxplot 그리기
					(나) boxplot을 벗어나는 이상치가 다수 존재하며, 출시가 변수에는 비정상적으로 높은 출시가(2.5억)를 가진 데이터가 관측됨.
						① KREAM 측에서의 입력 오류로, 올바른 값을 찾아 수정해주었다.
					(다) 출시일이 매우 오래된 (약 10년 이상) 제품들은 새로운 상품의 가치에 영향이 희박할 것이라 판단하여, 삭제하였다.
					(라) 출시가가 수 백 만원에 달하는 명품 신발의 경우, 일반적인 스니커즈에 대한 가격 예측에 적합하지 않다 판단하여, 삭제하였다.
				(4) 데이터 스케일링
					(가) RobustScale
						① 개념 : 분위수를 사용한 스케일링 방법으로, 평균과 분산을 고려하지 않아 이상치에 대해 Robust하다
						② 선정 이유 : boxplot으로 데이터를 시각화해보았을 때, 이상값이지만 분석에 고려해야할 필요가 있는 데이터들이 많이 분포해있었기에, 이상값에 크게 영향을 받지않는 스케일링 방법을 선택했다.
			다) 머신러닝을 위한 전처리 - Decision Tree 기반 모델
				(1) 시계열 데이터를 고려하지 않으므로 거래내역 변수 삭제
				(2) 범주형 변수를 정수화
					(가) Label Encoding
						① 개념 : n개의 범주에 각각 정수 수치를 할당하는 인코딩
						② 선정 이유 : Decision Tree 모델의 특성 상 정보량이 데이터 크기 대비 적어지는 더미 변수화를 사용하였을 때, 정보량이 적은 변수들을 배제하고 모델을 형성할 우려가 있다. 또한 Decision Tree 기반 모델은 Label Encoding 후의 수치에 크게 영향을 받지 않기 때문이다.
					(나) 콜라보레이션 브랜드 -> 신경망 모델과 같이 0, 1 변수화
					(다) 브랜드 / Cluster -> Label encoding
				(3) Outlier 탐색
					(가) matplotlib.pyplot 라이브러리를 통한 boxplot 그리기
					(나) boxplot을 벗어나는 이상치가 다수 존재하며, 출시가 변수에는 비정상적으로 높은 출시가(2.5억)를 가진 데이터가 관측됨.
						① KREAM 측에서의 입력 오류로, 올바른 값을 찾아 수정해주었다.
					(다) 출시일이 매우 오래된 (약 10년 이상) 제품들은 새로운 상품의 가치에 영향이 희박할 것이라 판단하여, 삭제하였다.
					(라) 출시가가 수 백 만원에 달하는 명품 신발의 경우, 일반적인 스니커즈에 대한 가격 예측에 적합하지 않다 판단하여, 삭제하였다.
				(4) 데이터 스케일링
					(가) RobustScale
						① 개념 : 분위수를 사용한 스케일링 방법으로, 평균과 분산을 고려하지 않아 이상치에 대해 Robust하다
						② 선정 이유 : boxplot으로 데이터를 시각화해보았을 때, 이상값이지만 분석에 고려해야할 필요가 있는 데이터들이 많이 분포해있었기에, 이상값에 크게 영향을 받지않는 스케일링 방법을 선택했다.
### 	라. 머신러닝 분석
		1) 사용 모델
			가) ANN 나) Decision Tree 기반 모델들
		2) 해당 모델 선정 이유
			가) 일반적인 선형 회귀 모델에 데이터를 적용해보았을 때, MAE가 상당히 크게 나타났다.
			나) 범주형 데이터를 인코딩 한 후, 분석에 적용할 때, 가장 정보 손실이 적을 것이라 판단되었다.
		2). ANN
			가) Tensorflow Keras
				(1) 개념 : 인공신경망을 형성하는 딥러닝 모델
			나) 모델 학습 / 평가 결과
				(1) 참값과 예측값을 시각화해보았을 때, 어느 정도 가격 패턴을 잘 따라가는 것처럼 보였다.
		2). Decision Tree 기반 모델
			가) 사용 모델
				(1) Decision Tree (2) RandomForest (3) GradientBoost (4) Lightgbm (5) XGboost
			나) 모델 학습 / 평가 결과
				(1) Decision Tree의 MAE 는 약 8만 수준으로 높게 나왔으나, 나머지 4개의 모델은 약 6만 초 중반대의 오차로 성능이 비슷하였다.
				(2) 참값과 예측값을 시각화해보았을 때, Decision Tree를 제외한 4개의 모델들은 이상치에 가까운 값을 예측하는 데에는 실패했으나, 일반적인 값에서는 가격의 패턴을 잘 따라가는 것으로 보였다.

## III. 서비스 개발
	가. 크롬 확장프로그램
	나. 선정 이유
	다. 제공 방식
### 	라. 개발 과정
		1) 사용 기술
			가) Vue.js
				(1) 소개 : UI를 빠르게 개발하기 위해 만들어진 자바스크립트 프레임워크
				(2) 장점 : 새로 배우기 쉽고, 프레임워크 자체가 가볍기 때문에 빠른 렌더링이 가능하다.
			나) Javascript
			다) Flask
				(1) 소개 : 파이썬으로 웹 어플리케이션을 구축할 수 있도록 도와주는 라이브러리.
				(2) 기능 : 서버처럼 작동해 웹에서 전송되는 데이터를 받아, 머신러닝 예측 결과를 다시 돌려주는 API 역할을 할 수 있다.
			라) Ubuntu
				(1) Vue.js를 통한 개발 중, 실시간으로 build하며 개발하기 위해 사용했다.
		2) 프로그램 구조
			가) manifest.json
				(1) 확장프로그램에 대한 정보를 담은 파일
				(2) 자바스크립트 파일과 연결, 퍼미션에 획득에 대한 기능을 한다.
			가) popup.html
				(1) 크롬 확장프로그램 아이콘을 누르면 나타나는 팝업 창.
				(2) 머신러닝 예측 결과를 받아와 신발 정보와 함께 표시하는 기능을 한다.
			나) background.js
				(1) 확장프로그램 설치 시 부터 작동하는 백그라운드 자바스크립트
				(2) 필요한 함수들을 정의하고 content-script와 통신한다.
			다) content-script
				(1) preload.js
					(가) 웹사이트(DOM)가 로드 되기 시작할 때 작동하며, site1.js 에서 필요로 할 기능을 가진 함수들을 정의한다.
				(2) site1.js
					(가) DOM이 로드 된 후 작동한다.
					(나) 머신러닝 예측에 필요한 신발 정보들을 웹사이트에서 파싱하여, 서버로 직접 전송한다.
					(다) 서버에서 예측 값이 나왔을 때, content-script에서 회신 받을 수 있도록 한다.
			라) server
				(1) 서버 내 작동 과정
					(가) content-script(site1.js) 에서 json 데이터를 서버로 전송
					(나) 서버가 이를 받고 데이터프레임 형태로 변환하여 저장
					(다) 데이터 전처리
					(라) 머신러닝 모델을 로드하여 리셀 가격을 예측
					(마) predict value를 다시 content-script로 회신

				

